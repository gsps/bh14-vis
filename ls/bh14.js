// Generated by LiveScript 1.2.0
(function(){
  var prelude, V3, mod, clamp, Vis, BEATS_PER_BAR, VisState, Tri, Sequence, SidestepSequence, ShearSequence, TranslateSequence, CircleSequence, main;
  prelude = require('prelude-ls');
  V3 = function(x, y, z){
    return new THREE.Vector3(x, y, z);
  };
  mod = function(a, b){
    return (a % b + b) % b;
  };
  clamp = curry$(function(a, b, x){
    switch (false) {
    case !(x < a):
      return a;
    case !(x > b):
      return b;
    default:
      return x;
    }
  });
  Vis = new function(){
    var this$ = this;
    this.newTriGeom = function(v1, v2, v3){
      var geom;
      geom = new THREE.Geometry();
      geom.vertices.push(v1);
      geom.vertices.push(v2);
      geom.vertices.push(v3);
      geom.faces.push(new THREE.Face3(0, 1, 2));
      geom.computeFaceNormals();
      return geom;
    };
    this.newTriMesh = function(geom, color){
      var mesh;
      color == null && (color = 0xffffff);
      return mesh = new THREE.Mesh(geom, new THREE.MeshBasicMaterial({
        color: color
      }));
    };
    this.triBaseLength = 1.0;
    this.triRatio = 1 / 1.61;
    this.triBaseHeight = this.triBaseLength * this.triRatio;
    this.triGeom = (function(l, h){
      return this.newTriGeom(V3(-l / 2, 0, 0), V3(l / 2, 0, 0), V3(0, h, 0));
    }.call(this, this.triBaseLength, this.triBaseHeight));
    this.translateGeom = function(geom, vAdd){
      geom.vertices.forEach(function(it){
        return it.add(vAdd);
      });
      return geom;
    };
    this.computeFlipped = function(other){
      var vMul, vAdd, ref$, v1, v2, v3;
      vMul = V3(1, -1, 1);
      vAdd = V3(0, other.vertices[2].y, 0);
      ref$ = other.vertices.map(function(it){
        return it.clone().multiply(vMul).add(vAdd);
      }), v1 = ref$[0], v2 = ref$[1], v3 = ref$[2];
      return this$.newTriGeom(v3, v2, v1);
    };
    this.triGeomFlipped = this.computeFlipped(this.triGeom);
    this.computeScaled = function(n){
      var fact, vX, vY, ref$, v1, v2, v3;
      fact = 1 / Math.exp(2, n);
      vX = V3(this$.triBaseLength * fact * 0.5, 0, 0);
      vY = V3(0, this$.triBaseHeight * fact, 0);
      ref$ = this$.triGeom.vertices.map(function(it){
        return it.clone().multiplyScalar(fact);
      }), v1 = ref$[0], v2 = ref$[1], v3 = ref$[2];
      return this$.newTriGeom(v1.sub(vX), v2.add(vX), v3.add(vY));
    };
    this.triGeomSmall = this.computeScaled(1);
    this.triGeomSmallFlipped = this.computeFlipped(this.triGeomSmall);
    this.triBase = function(cx, cy){
      var geom, x$;
      geom = (function(){
        switch (false) {
        case cx % 2 !== 0:
          return this.triGeom;
        default:
          return this.triGeomFlipped;
        }
      }.call(this));
      x$ = this.newTriMesh(geom);
      x$.renderDepth = cx % 2;
      return x$;
    };
    this.triMeshes = function(callback){
      var i$, x, j$, y;
      for (i$ = -26; i$ <= 25; ++i$) {
        x = i$;
        for (j$ = -13; j$ <= 12; ++j$) {
          y = j$;
          callback(this.triBase(x, y), x, y);
        }
      }
    };
    this.triBaseDefaultParams = {
      oddExtra: 1.0,
      staggerAB: 1.0,
      staggerA: 1.0,
      staggerB: 1.0
    };
    this.updateTriMeshes = function(visState){
      var params, stagger, oddExtra, updateMesh, this$ = this;
      params = visState.params;
      stagger = this.triBaseLength / 2 * params.staggerAB;
      oddExtra = params.oddExtra;
      updateMesh = function(mesh, cx, cy){
        var cxp, mx, my, color, visible, x$;
        cxp = cx;
        mx = (function(){
          switch (false) {
          case cy % 2 !== 0:
            return cxp * stagger * params.staggerA;
          default:
            return (cxp + oddExtra) * stagger * params.staggerB;
          }
        }());
        my = cy * this$.triBaseHeight;
        color = 0xffffff;
        visible = true;
        if (cx % 2 === 0) {
          color = 0x00ffff;
        }
        x$ = mesh;
        if (mesh.position.x !== mx || mesh.position.y !== my) {
          x$.position.set(mx, my, 0);
        }
        if (mesh.visible !== visible) {
          x$.visible = visible;
        }
        if (mesh.material.color.getHex() !== color) {
          x$.material.color.setHex(color);
        }
      };
      visState.trisByCoord(updateMesh);
    };
    this.miscDefaultParams = {
      effects: {
        bloom: false,
        dotScreen: false,
        glitch: false
      }
    };
  };
  BEATS_PER_BAR = 4;
  VisState = (function(){
    VisState.displayName = 'VisState';
    var prototype = VisState.prototype, constructor = VisState;
    function VisState(time, running, perspCam, bpm, phase, params){
      var defaultParams;
      this.time = time != null ? time : 0.0;
      this.running = running != null ? running : true;
      this.perspCam = perspCam != null ? perspCam : false;
      this.bpm = bpm != null ? bpm : 128.0;
      this.phase = phase != null ? phase : 0.0;
      this.clearTris();
      defaultParams = import$(import$({}, Vis.triBaseDefaultParams), Vis.miscDefaultParams);
      this.params = import$(defaultParams, this.params || {});
      this.seqs = [new CircleSequence(), new ShearSequence(), new TranslateSequence(), new SidestepSequence()];
      this.activeSeqIndex = 0;
      this.nextSeqIndex = 0;
      this.nextSeqStart = 0;
    }
    prototype.step = function(dt){
      if (!this.running) {
        return this;
      }
      this.time += dt;
      if (this.nextSeqIndex !== void 8 && this.time >= this.nextSeqStart) {
        this.activeSeqIndex = this.nextSeqIndex;
        this.seqs[this.activeSeqIndex].setup(this);
        this.nextSeqIndex = void 8;
        this.nextSeqStart = void 8;
        this.phase = this.phase % (BEATS_PER_BAR * this.tpb);
      }
      this.seqs[this.activeSeqIndex].step(this);
      return this;
    };
    prototype.scheduleSequence = function(seqIndex){
      this.nextSeqIndex = seqIndex;
      return this.nextSeqStart = this.time + this.tpb * BEATS_PER_BAR * (1.0 - this.pBar);
    };
    prototype.clearTris = function(){
      this.tris = [];
    };
    prototype.coord2key = function(cx, cy){
      return (cx + 500) * 1000 + (cy + 500);
    };
    prototype.key2coord = function(key){
      return [Math.floor(key / 1000) - 500, key % 1000 - 500];
    };
    prototype.addTri = function(mesh, cx, cy){
      this.tris.push([cx, cy, mesh]);
    };
    prototype.trisByCoord = function(callback){
      var i$, ref$, len$, ref1$, cx, cy, mesh;
      for (i$ = 0, len$ = (ref$ = this.tris).length; i$ < len$; ++i$) {
        ref1$ = ref$[i$], cx = ref1$[0], cy = ref1$[1], mesh = ref1$[2];
        callback(mesh, cx, cy);
      }
    };
    Object.defineProperty(prototype, 'bpm', {
      get: function(){
        return 60.0 * 1000.0 / this.tpb;
      },
      set: function(bpm){
        this.tpb = 60.0 * 1000.0 / bpm;
      },
      configurable: true,
      enumerable: true
    });
    Object.defineProperty(prototype, 'vTime', {
      get: function(){
        return this.time - this.phase;
      },
      configurable: true,
      enumerable: true
    });
    Object.defineProperty(prototype, 'pBeat', {
      get: function(){
        return (this.vTime % this.tpb) / this.tpb;
      },
      configurable: true,
      enumerable: true
    });
    Object.defineProperty(prototype, 'vBeat', {
      get: function(){
        return this.vTime / this.tpb;
      },
      configurable: true,
      enumerable: true
    });
    Object.defineProperty(prototype, 'vBarBeat', {
      get: function(){
        return (this.vTime % (BEATS_PER_BAR * this.tpb)) / this.tpb;
      },
      configurable: true,
      enumerable: true
    });
    Object.defineProperty(prototype, 'pBar', {
      get: function(){
        return (function(f){
          return (this.vTime % f) / f;
        }.call(this, BEATS_PER_BAR * this.tpb));
      },
      configurable: true,
      enumerable: true
    });
    Object.defineProperty(prototype, 'vBar', {
      get: function(){
        return (function(f){
          return this.vTime / f;
        }.call(this, BEATS_PER_BAR * this.tpb));
      },
      configurable: true,
      enumerable: true
    });
    return VisState;
  }());
  Tri = (function(){
    Tri.displayName = 'Tri';
    var prototype = Tri.prototype, constructor = Tri;
    function Tri(){
      var geom, vBase;
      geom = (function(){
        switch (false) {
        case cx % 2 !== 0:
          return this.triGeom;
        default:
          return this.triGeomFlipped;
        }
      }.call(this));
      this.mLarge = Vis.newTriMesh(geom);
      vBase = V3(this.triBaseLength, this.triBaseHeight, 0);
      this.msSmall = [V3(-1, 0, 0), V3(1, 0, 0), V3(0, 1, 0)].map(function(it){
        return it.multiply(vBase).apply(this, arguments);
      });
    }
    return Tri;
  }());
  Sequence = (function(){
    Sequence.displayName = 'Sequence';
    var prototype = Sequence.prototype, constructor = Sequence;
    function Sequence(){
      this.params = this.defaultParams();
    }
    prototype.setup = function(visState){};
    prototype.step = function(visState){};
    prototype.basicGridDefaultParams = function(){
      return {
        oddExtra: 1.0,
        staggerAB: 1.0,
        staggerA: 1.0,
        staggerB: 1.0,
        xAddFunc: void 8,
        yAddFunc: void 8,
        cxFunc: void 8,
        cyFunc: void 8
      };
    };
    prototype.buildBasicGridUpdater = function(params){
      var stagger, oddExtra, updateMesh, this$ = this;
      params == null && (params = {});
      params = import$(import$({}, this.basicGridDefaultParams()), params);
      stagger = Vis.triBaseLength / 2 * params.staggerAB;
      oddExtra = params.oddExtra;
      return updateMesh = function(mesh, cx, cy){
        var cxt, cyt, mx, my, visible, color, x$;
        cxt = params.cxFunc ? params.cxFunc(cx, cy) : cx;
        cyt = params.cyFunc ? params.cyFunc(cx, cy) : cy;
        mx = (function(){
          switch (false) {
          case cy % 2 !== 0:
            return cxt * stagger * params.staggerA;
          default:
            return (cxt + oddExtra) * stagger * params.staggerB;
          }
        }());
        mx += params.xAddFunc ? params.xAddFunc(cx, cy) : 0;
        my = cyt * Vis.triBaseHeight;
        my += params.yAddFunc ? params.yAddFunc(cx, cy) : 0;
        visible = true;
        color = 0xffffff;
        if (cx % 2 === 0) {
          color = 0x00ffff;
        }
        x$ = mesh;
        if (mesh.position.x !== mx || mesh.position.y !== my) {
          x$.position.set(mx, my, 0);
        }
        if (mesh.visible !== visible) {
          x$.visible = visible;
        }
        if (mesh.material.color.getHex() !== color) {
          x$.material.color.setHex(color);
        }
      };
    };
    prototype.beatRangeProgress = function(vBeat, a, b){
      if (!(vBeat >= a && vBeat <= b)) {
        return;
      }
      return (vBeat - a) / (b - a);
    };
    return Sequence;
  }());
  SidestepSequence = (function(superclass){
    var prototype = extend$((import$(SidestepSequence, superclass).displayName = 'SidestepSequence', SidestepSequence), superclass).prototype, constructor = SidestepSequence;
    prototype.defaultParams = function(){
      return {
        rpBar: 0.5
      };
    };
    prototype.setup = function(visState){
      return visState.trisByCoord(this.buildBasicGridUpdater());
    };
    prototype.step = function(visState){
      var angle, beat, updateMesh, this$ = this;
      angle = visState.vBar * this.params.rpBar * -2 * Math.PI;
      beat = visState.vBeat % 4;
      updateMesh = function(mesh, cx, cy){
        var defaultColor, activeColor, dist0, dist, color;
        defaultColor = new THREE.Color(0xffffff);
        activeColor = new THREE.Color(0x00ffff);
        dist0 = mod(cx, 4) - beat;
        dist = clamp(0, 1)(
        Math.min(Math.abs(
        dist0), Math.abs(
        dist0 + 4)));
        color = defaultColor.lerp(activeColor, 1.0 - dist / 1.0);
        mesh.material.color.set(color);
      };
      return visState.trisByCoord(updateMesh);
    };
    function SidestepSequence(){
      SidestepSequence.superclass.apply(this, arguments);
    }
    return SidestepSequence;
  }(Sequence));
  ShearSequence = (function(superclass){
    var prototype = extend$((import$(ShearSequence, superclass).displayName = 'ShearSequence', ShearSequence), superclass).prototype, constructor = ShearSequence;
    prototype.defaultParams = function(){
      return {};
    };
    prototype.step = function(visState){
      var beat, barNum, onBar, BEAT_PERIOD, expo, expo1, p, p0, basicUpdater;
      beat = visState.vBeat;
      barNum = Math.floor(visState.vBar);
      onBar = barNum % 2 === 1;
      BEAT_PERIOD = 8;
      expo = Math.cos(((beat + 3.0) % BEAT_PERIOD) / BEAT_PERIOD * 2 * Math.PI) / 8.0 + 0.125;
      expo1 = 1.0 + expo;
      p = this.beatRangeProgress(beat % 4, 0.0, 1.0);
      p0 = TWEEN.Easing.Quadratic.InOut(p || 0);
      basicUpdater = this.buildBasicGridUpdater({
        cxFunc: function(cx, cy){
          switch (false) {
          case !(cx < 0):
            return -Math.pow(-cx, expo1) + cx * expo * 2.0;
          default:
            return Math.pow(cx, expo1) + cx * expo * 2.0;
          }
        },
        cyFunc: function(cx, cy){
          switch (false) {
          case !(cx >= -1 && cx <= 1):
            return cy;
          case !(barNum % 4 === 1 && mod(cx, 2) === 0):
            return cy + 2 * p0;
          case !(barNum % 4 === 3 && mod(cx, 2) === 1):
            return cy - 2 * p0;
          default:
            return cy;
          }
        }
      });
      return visState.trisByCoord(function(mesh, cx, cy){
        var color;
        basicUpdater(mesh, cx, cy);
        color = cx % 2 === 0 ? 0x00ffff : 0xffffff;
        if (p !== void 8) {
          if (barNum % 4 === 1 && mod(cx, 2) === 0) {
            color = 0xff00ff;
          }
          if (barNum % 4 === 3 && mod(cx, 2) === 1) {
            color = 0xffff00;
          }
        }
        return mesh.material.color.setHex(color);
      });
    };
    function ShearSequence(){
      ShearSequence.superclass.apply(this, arguments);
    }
    return ShearSequence;
  }(Sequence));
  TranslateSequence = (function(superclass){
    var prototype = extend$((import$(TranslateSequence, superclass).displayName = 'TranslateSequence', TranslateSequence), superclass).prototype, constructor = TranslateSequence;
    prototype.defaultParams = function(){
      return {};
    };
    prototype.step = function(visState){
      var beat, beat4, barNum, sign, updater;
      beat = visState.vBeat;
      beat4 = beat % 4;
      barNum = Math.floor(visState.vBar);
      sign = barNum % 2 === 0
        ? 1
        : -1;
      updater = this.buildBasicGridUpdater({
        staggerAB: beat4 / 4.0 + 1.0,
        yAddFunc: function(cx, cy){
          return cx * sign * beat4 / 8.0;
        }
      });
      return visState.trisByCoord(updater);
    };
    function TranslateSequence(){
      TranslateSequence.superclass.apply(this, arguments);
    }
    return TranslateSequence;
  }(Sequence));
  CircleSequence = (function(superclass){
    var prototype = extend$((import$(CircleSequence, superclass).displayName = 'CircleSequence', CircleSequence), superclass).prototype, constructor = CircleSequence;
    prototype.defaultParams = function(){
      return {
        minHWidth: 0.5,
        maxHWidth: 3.0,
        pulse: false
      };
    };
    prototype.setup = function(visState){
      return visState.trisByCoord(this.buildBasicGridUpdater());
    };
    prototype.step = function(visState){
      var beat, barNum, beat8norm, beat8normPingPong, R, cs, rcs, res$, i$, i, hWidth, basicUpdater;
      beat = visState.vBeat;
      barNum = Math.floor(visState.vBar);
      beat8norm = (beat % 8) / 8.0;
      beat8normPingPong = barNum % 2 === 0
        ? beat8norm
        : 1.0 - beat8norm;
      R = 30.0;
      cs = [0x007777, 0x009999, 0x00bbbb, 0x00ffff, 0x00bbbb, 0x009999, 0x007777];
      res$ = [];
      for (i$ = -3; i$ <= 3; ++i$) {
        i = i$;
        res$.push([(beat8norm + 0.25 * i) * R, cs[i + 3]]);
      }
      rcs = res$;
      if (visState.vBar < 2.0) {
        rcs.length -= 3;
      }
      hWidth = beat8normPingPong * (this.params.maxHWidth - this.params.minHWidth) + this.params.minHWidth;
      basicUpdater = this.buildBasicGridUpdater({
        staggerAB: this.params.pulse ? beat8normPingPong * 0.5 + 1.1 : 1.2
      });
      return visState.trisByCoord(function(mesh, cx, cy){
        var d, f, foundRc, color;
        basicUpdater(mesh, cx, cy);
        d = Math.sqrt(cx * cx + cy * cy);
        f = function(arg$){
          var r, c;
          r = arg$[0], c = arg$[1];
          return r >= 0 && (d > r - hWidth && d < r + hWidth);
        };
        foundRc = prelude.find(f, rcs);
        color = foundRc ? foundRc[1] : 0x000000;
        if (mesh.material.color.getHex !== color) {
          return mesh.material.color.setHex(color);
        }
      });
    };
    function CircleSequence(){
      CircleSequence.superclass.apply(this, arguments);
    }
    return CircleSequence;
  }(Sequence));
  main = function(){
    var stats, camera, scene, renderer, composer, object, light, renderPass, effectCopy, passes, passesOrder, visState, visStateGui, canvasWidth, canvasHeight, canvasRatio, cameraParams, perspCamActive, fetchCanvasSize, dpr, sampleRatio, init, onWindowResize, onKeyPress, rebuildTris, refreshEffectPasses, tLastStep;
    fetchCanvasSize = function(){
      var width;
      width = 24;
      canvasWidth = document.getElementById('renderArea').clientWidth;
      canvasHeight = document.getElementById('renderArea').clientHeight;
      canvasRatio = canvasWidth / canvasHeight;
      cameraParams = (function(height){
        return {
          left: width / -2,
          right: width / 2,
          top: height / 2,
          bottom: height / -2,
          near: -10,
          far: 10
        };
      }.call(this, width / canvasRatio));
    };
    dpr = window.devicePixelRatio !== void 8 ? window.devicePixelRatio : 1;
    sampleRatio = 2;
    init = function(){
      var bloomPass, dotScreenPass, glitchPass, x$, y$, z$, i$, ref$, len$, seq, folder, k, ref1$, v;
      fetchCanvasSize();
      renderer = new THREE.WebGLRenderer();
      renderer.setSize(canvasWidth, canvasHeight);
      renderer.autoClear = false;
      document.getElementById('renderArea').appendChild(renderer.domElement);
      stats = new Stats();
      stats.domElement.style.position = 'absolute';
      stats.domElement.style.bottom = '0px';
      stats.domElement.style.top = '0px';
      stats.domElement.style.zIndex = 100;
      document.body.appendChild(stats.domElement);
      visState = new VisState();
      scene = new THREE.Scene();
      rebuildTris();
      composer = new THREE.EffectComposer(renderer);
      composer.setSize(canvasWidth * dpr * sampleRatio, canvasHeight * dpr * sampleRatio);
      renderPass = new THREE.RenderPass(scene, null);
      composer.addPass(renderPass);
      bloomPass = new THREE.BloomPass();
      bloomPass.renderToScreen = false;
      bloomPass.enabled = false;
      composer.addPass(bloomPass);
      effectCopy = new THREE.ShaderPass(THREE.CopyShader);
      effectCopy.renderToScreen = true;
      composer.addPass(effectCopy);
      dotScreenPass = new THREE.DotScreenPass();
      dotScreenPass.renderToScreen = false;
      dotScreenPass.enabled = false;
      composer.addPass(dotScreenPass);
      glitchPass = new THREE.GlitchPass(32);
      glitchPass.goWild = true;
      glitchPass.renderToScreen = false;
      glitchPass.enabled = false;
      composer.addPass(glitchPass);
      passes = {
        bloom: bloomPass,
        dotScreen: dotScreenPass,
        glitch: glitchPass
      };
      passesOrder = ['bloom', 'dotScreen', 'glitch'];
      onWindowResize();
      visStateGui = (x$ = new dat.GUI(), x$.add(visState, 'time').listen(), x$.add(visState, 'running').listen(), x$.add(visState, 'perspCam').onFinishChange(onWindowResize), x$.add(visState, 'vBarBeat').listen(), x$.add(visState, 'bpm'), y$ = x$.addFolder('triBase'), y$.add(visState.params, 'oddExtra', -5, 5).onFinishChange(rebuildTris), y$.add(visState.params, 'staggerAB', -2, 2).onFinishChange(rebuildTris), y$.add(visState.params, 'staggerA', -2, 2).onFinishChange(rebuildTris), y$.add(visState.params, 'staggerB', -2, 2).onFinishChange(rebuildTris), z$ = x$.addFolder('effects'), z$.add(visState.params.effects, 'bloom').onFinishChange(refreshEffectPasses), z$.add(visState.params.effects, 'dotScreen').onFinishChange(refreshEffectPasses), z$.add(visState.params.effects, 'glitch').onFinishChange(refreshEffectPasses), x$);
      console.log(visState.seqs[0]);
      for (i$ = 0, len$ = (ref$ = visState.seqs).length; i$ < len$; ++i$) {
        seq = ref$[i$];
        folder = visStateGui.addFolder(seq.constructor.displayName);
        for (k in ref1$ = seq.params) {
          v = ref1$[k];
          folder.add(seq.params, k);
        }
      }
      window.addEventListener('resize', onWindowResize, 10, false);
      window.addEventListener('keypress', onKeyPress, false);
    };
    onWindowResize = function(){
      var x$, y$;
      fetchCanvasSize();
      if (perspCamActive !== visState.perspCam) {
        if (visState.perspCam) {
          camera = (x$ = new THREE.PerspectiveCamera(24, canvasRatio, 10, 50), y$ = x$.position, y$.x = 17, y$.z = 15.0, x$.rotation.y = 0.9, x$);
        } else {
          camera = (function(p){
            return new THREE.OrthographicCamera(p.left, p.right, p.top, p.bottom, p.near, p.far);
          }.call(this, cameraParams));
        }
        renderPass.camera = camera;
        perspCamActive = visState.perspCam;
      }
      if (!perspCamActive) {
        import$(camera, cameraParams);
        camera.updateProjectionMatrix();
      }
      renderer.setSize(canvasWidth, canvasHeight);
      composer.setSize(canvasWidth * dpr * sampleRatio, canvasHeight * dpr * sampleRatio);
    };
    onKeyPress = function(e){
      switch (false) {
      case e.keyCode !== 32:
        visState.running = !visState.running;
        e.preventDefault();
        break;
      case !(e.keyCode === 84 || e.keyCode === 116):
        console.log('TTT');
        e.preventDefault();
        break;
      case e.keyCode !== 97:
        visState.scheduleSequence(mod(visState.activeSeqIndex - 1, visState.seqs.length));
        e.preventDefault();
        break;
      case e.keyCode !== 115:
        visState.scheduleSequence(mod(visState.activeSeqIndex + 1, visState.seqs.length));
        e.preventDefault();
      }
    };
    rebuildTris = function(){
      if (object != null) {
        scene.remove(object);
      }
      object = new THREE.Object3D();
      scene.add(object);
      visState.clearTris();
      Vis.triMeshes(function(mesh, cx, cy){
        object.add(mesh);
        return visState.addTri(mesh, cx, cy);
      });
    };
    refreshEffectPasses = function(){
      var lastActivePass, i$, ref$, len$, name, pass;
      lastActivePass = void 8;
      for (i$ = 0, len$ = (ref$ = passesOrder).length; i$ < len$; ++i$) {
        name = ref$[i$];
        pass = passes[name];
        pass.enabled = visState.params.effects[name];
        pass.renderToScreen = false;
        if (pass.enabled) {
          lastActivePass = name;
        }
      }
      effectCopy.renderToScreen = lastActivePass === 'bloom' || lastActivePass === void 8;
      if (lastActivePass) {
        passes[lastActivePass].renderToScreen = true;
      }
      effectCopy.enabled = true;
    };
    tLastStep = 0;
    function step(tNow){
      var dt;
      stats.begin();
      requestAnimationFrame(step);
      tNow || (tNow = 0);
      dt = tNow - tLastStep;
      visState.step(dt);
      tLastStep = tNow;
      renderer.clear();
      composer.render();
      return stats.end();
    }
    init();
    step();
  };
  main();
  function curry$(f, bound){
    var context,
    _curry = function(args) {
      return f.length > 1 ? function(){
        var params = args ? args.concat() : [];
        context = bound ? context || this : this;
        return params.push.apply(params, arguments) <
            f.length && arguments.length ?
          _curry.call(context, params) : f.apply(context, params);
      } : f;
    };
    return _curry();
  }
  function import$(obj, src){
    var own = {}.hasOwnProperty;
    for (var key in src) if (own.call(src, key)) obj[key] = src[key];
    return obj;
  }
  function extend$(sub, sup){
    function fun(){} fun.prototype = (sub.superclass = sup).prototype;
    (sub.prototype = new fun).constructor = sub;
    if (typeof sup.extended == 'function') sup.extended(sub);
    return sub;
  }
}).call(this);
